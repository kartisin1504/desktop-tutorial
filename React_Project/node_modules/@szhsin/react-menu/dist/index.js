function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var menuContainerClass = 'rc-menu-container';
var menuClass = 'rc-menu';
var menuButtonClass = 'rc-menu-button';
var menuArrowClass = 'arrow';
var menuItemClass = 'item';
var menuDividerClass = 'divider';
var menuHeaderClass = 'header';
var subMenuClass = 'submenu';
var radioGroupClass = 'radio-group';
var initialHoverIndex = -1;
var MenuListContext = /*#__PURE__*/React__default.createContext({
  hoverIndex: initialHoverIndex
});
var EventHandlersContext = /*#__PURE__*/React__default.createContext({});
var RadioGroupContext = /*#__PURE__*/React__default.createContext({});
var SettingsContext = /*#__PURE__*/React__default.createContext({});
var Keys = Object.freeze({
  'ENTER': 'Enter',
  'ESC': 'Escape',
  'SPACE': ' ',
  'HOME': 'Home',
  'END': 'End',
  'LEFT': 'ArrowLeft',
  'RIGHT': 'ArrowRight',
  'UP': 'ArrowUp',
  'DOWN': 'ArrowDown'
});
var HoverIndexActionTypes = Object.freeze({
  'RESET': 0,
  'SET': 1,
  'UNSET': 2,
  'INCREASE': 3,
  'DECREASE': 4,
  'FIRST': 5,
  'LAST': 6
});
var CloseReason = Object.freeze({
  'CLICK': 'click',
  'CANCEL': 'cancel',
  'BLUR': 'blur',
  'RESIZE': 'resize',
  'SCROLL': 'scroll'
});

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var stylePropTypes = function stylePropTypes(name) {
  var _ref;

  return _ref = {}, _ref[name ? name + "ClassName" : 'className'] = PropTypes.oneOfType([PropTypes.string, PropTypes.func]), _ref[name ? name + "Styles" : 'styles'] = PropTypes.oneOfType([PropTypes.object, PropTypes.func]), _ref;
};
var sharedMenuPropTypes = _extends({}, stylePropTypes(), stylePropTypes('arrow'), {
  'aria-label': PropTypes.string,
  arrow: PropTypes.bool,
  offsetX: PropTypes.number,
  offsetY: PropTypes.number,
  align: PropTypes.oneOf(['start', 'center', 'end']),
  direction: PropTypes.oneOf(['left', 'right', 'top', 'bottom']),
  position: PropTypes.oneOf(['auto', 'anchor', 'initial']),
  overflow: PropTypes.oneOf(['auto', 'visible', 'hidden']),
  children: PropTypes.node.isRequired
});
var menuPropTypesBase = _extends({}, sharedMenuPropTypes, {
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  animation: PropTypes.bool,
  debugging: PropTypes.bool,
  viewScroll: PropTypes.oneOf(['auto', 'close', 'initial']),
  onClick: PropTypes.func
});
var sharedMenuDefaultProp = {
  offsetX: 0,
  offsetY: 0,
  align: 'start',
  direction: 'bottom',
  position: 'auto',
  overflow: 'visible'
};
var menuDefaultPropsBase = _extends({}, sharedMenuDefaultProp, {
  animation: true,
  viewScroll: 'initial'
});

var defineName = function defineName(component, name) {
  return Object.defineProperty(component, '__name__', {
    value: name,
    writable: false
  });
};
var safeCall = function safeCall(fn) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return typeof fn === 'function' ? fn.apply(void 0, args) : fn;
};
var bem = function bem(block, element, modifiers) {
  if (modifiers === void 0) {
    modifiers = {};
  }

  return function (userClassName, userModifiers) {
    var blockElement = element ? block + "__" + element : block;
    var className = blockElement;

    for (var _i = 0, _Object$keys = Object.keys(modifiers); _i < _Object$keys.length; _i++) {
      var name = _Object$keys[_i];
      var value = modifiers[name];

      if (value) {
        className += " " + blockElement + "--";
        className += value === true ? name : name + "-" + value;
      }
    }

    if (typeof userClassName === 'function') {
      userClassName = userClassName(userModifiers || modifiers);
    }

    if (typeof userClassName === 'string') {
      userClassName = userClassName.trim();
      if (userClassName) className += " " + userClassName;
    }

    return className;
  };
};

var isObject = function isObject(obj) {
  return obj && typeof obj === 'object';
};

var flatStyles = function flatStyles(styles, modifiers) {
  if (typeof styles === 'function') return styles(modifiers);
  if (!isObject(styles)) return undefined;
  if (!modifiers) return styles;
  var style = {};

  for (var _i2 = 0, _Object$keys2 = Object.keys(styles); _i2 < _Object$keys2.length; _i2++) {
    var prop = _Object$keys2[_i2];
    var value = styles[prop];

    if (isObject(value)) {
      var modifierValue = modifiers[prop];

      if (typeof modifierValue === 'string') {
        for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {
          var nestedProp = _Object$keys3[_i3];
          var nestedValue = value[nestedProp];

          if (isObject(nestedValue)) {
            if (nestedProp === modifierValue) {
              Object.assign(style, nestedValue);
            }
          } else {
            style[nestedProp] = nestedValue;
          }
        }
      } else if (modifierValue) {
        Object.assign(style, value);
      }
    } else {
      style[prop] = value;
    }
  }

  return style;
};

var useActiveState = function useActiveState(isHovering, customKey) {
  var _useState = React.useState(false),
      active = _useState[0],
      setActive = _useState[1];

  var activeKeys = React.useMemo(function () {
    return [Keys.SPACE, Keys.ENTER].concat(customKey ? [customKey] : []);
  }, [customKey]);
  return {
    isActive: active,
    onPointerDown: React.useCallback(function (e) {
      e.currentTarget.setPointerCapture(e.pointerId);
      setActive(true);
    }, []),
    onPointerUp: React.useCallback(function (e) {
      e.currentTarget.releasePointerCapture(e.pointerId);
    }, []),
    onLostPointerCapture: React.useCallback(function () {
      setActive(false);
    }, []),
    onKeyDown: React.useCallback(function (e) {
      if (isHovering && activeKeys.includes(e.key)) {
        setActive(true);
      }
    }, [isHovering, activeKeys]),
    onKeyUp: React.useCallback(function (e) {
      if (activeKeys.includes(e.key)) {
        setActive(false);
      }
    }, [activeKeys]),
    onBlur: React.useCallback(function () {
      setActive(false);
    }, [])
  };
};

var useItemState = function useItemState(disabled, index) {
  var ref = React.useRef(null);

  var _useContext = React.useContext(MenuListContext),
      isParentOpen = _useContext.isParentOpen,
      hoverIndex = _useContext.hoverIndex,
      hoverIndexDispatch = _useContext.hoverIndexDispatch;

  var isHovering = hoverIndex === index;
  var isDisabled = disabled ? true : undefined;
  React.useEffect(function () {
    if (isHovering && isParentOpen) {
      ref.current && ref.current.focus();
    }
  }, [isHovering, isParentOpen]);
  return {
    ref: ref,
    isHovering: isHovering,
    isDisabled: isDisabled,
    setHover: React.useCallback(function () {
      if (!isDisabled) hoverIndexDispatch({
        type: HoverIndexActionTypes.SET,
        index: index
      });
    }, [isDisabled, hoverIndexDispatch, index]),
    unsetHover: React.useCallback(function () {
      if (!isDisabled) hoverIndexDispatch({
        type: HoverIndexActionTypes.UNSET,
        index: index
      });
    }, [isDisabled, hoverIndexDispatch, index])
  };
};

var useMenuChange = function useMenuChange(onChange, isOpen) {
  var prevOpen = React.useRef(isOpen);
  React.useEffect(function () {
    if (prevOpen.current !== isOpen) safeCall(onChange, {
      open: isOpen
    });
    prevOpen.current = isOpen;
  }, [onChange, isOpen]);
};

var FocusPositions = Object.freeze({
  'INITIAL': 'initial',
  'FIRST': 'first',
  'LAST': 'last'
});
var MenuStates = Object.freeze({
  'UNMOUNTED': 0,
  'CLOSED': 1,
  'OPEN': 2
});
var MenuStateActionType = Object.freeze({
  'OPEN': 0,
  'CLOSE': 1,
  'TOGGLE': 2
});
var useMenuState = function useMenuState(keepMounted) {
  if (keepMounted === void 0) {
    keepMounted = true;
  }

  var _useState = React.useState({
    position: FocusPositions.INITIAL
  }),
      menuItemFocus = _useState[0],
      setMenuItemFocus = _useState[1];

  var _useReducer = React.useReducer(menuStateReducer, MenuStates.UNMOUNTED),
      menuState = _useReducer[0],
      dispatch = _useReducer[1];

  function menuStateReducer(state, _ref) {
    var type = _ref.type;

    switch (type) {
      case MenuStateActionType.OPEN:
        return MenuStates.OPEN;

      case MenuStateActionType.CLOSE:
        if (state === MenuStates.OPEN) {
          return keepMounted ? MenuStates.CLOSED : MenuStates.UNMOUNTED;
        } else {
          return state;
        }

      case MenuStateActionType.TOGGLE:
        if (state === MenuStates.OPEN) {
          return keepMounted ? MenuStates.CLOSED : MenuStates.UNMOUNTED;
        } else {
          return MenuStates.OPEN;
        }

      default:
        throw new Error('menuStateReducer: unknown action type');
    }
  }

  return {
    isMounted: menuState !== MenuStates.UNMOUNTED,
    isOpen: menuState === MenuStates.OPEN,
    menuItemFocus: menuItemFocus,
    openMenu: React.useCallback(function (menuItemFocus) {
      if (menuItemFocus === void 0) {
        menuItemFocus = FocusPositions.INITIAL;
      }

      setMenuItemFocus({
        position: menuItemFocus
      });
      dispatch({
        type: MenuStateActionType.OPEN
      });
    }, []),
    closeMenu: React.useCallback(function () {
      return dispatch({
        type: MenuStateActionType.CLOSE
      });
    }, []),
    toggleMenu: React.useCallback(function (menuItemFocus) {
      if (menuItemFocus === void 0) {
        menuItemFocus = FocusPositions.INITIAL;
      }

      setMenuItemFocus({
        position: menuItemFocus
      });
      dispatch({
        type: MenuStateActionType.TOGGLE
      });
    }, [])
  };
};

var MenuButton = defineName( /*#__PURE__*/React__default.memo( /*#__PURE__*/React__default.forwardRef(function MenuButton(_ref, ref) {
  var id = _ref.id,
      className = _ref.className,
      styles = _ref.styles,
      isOpen = _ref.isOpen,
      disabled = _ref.disabled,
      children = _ref.children,
      onClick = _ref.onClick,
      onKeyDown = _ref.onKeyDown;
  var modifiers = Object.freeze({
    open: isOpen
  });
  return /*#__PURE__*/React__default.createElement("button", {
    id: id,
    className: bem(menuButtonClass, null, modifiers)(className),
    style: flatStyles(styles, modifiers),
    "aria-haspopup": "true",
    "aria-expanded": isOpen,
    "aria-disabled": disabled,
    ref: ref,
    disabled: disabled,
    onClick: onClick,
    onKeyDown: onKeyDown
  }, children);
})), 'MenuButton');
MenuButton.propTypes = _extends({}, stylePropTypes(), {
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  isOpen: PropTypes.bool,
  disabled: PropTypes.bool,
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func,
  onKeyDown: PropTypes.func
});

var MenuList = defineName( /*#__PURE__*/React__default.memo(function MenuList(_ref) {
  var ariaLabel = _ref.ariaLabel,
      className = _ref.className,
      styles = _ref.styles,
      arrowClassName = _ref.arrowClassName,
      arrowStyles = _ref.arrowStyles,
      anchorPoint = _ref.anchorPoint,
      anchorRef = _ref.anchorRef,
      containerRef = _ref.containerRef,
      arrow = _ref.arrow,
      align = _ref.align,
      direction = _ref.direction,
      position = _ref.position,
      overflow = _ref.overflow,
      isOpen = _ref.isOpen,
      isMounted = _ref.isMounted,
      isDisabled = _ref.isDisabled,
      menuItemFocus = _ref.menuItemFocus,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      children = _ref.children,
      onKeyDown = _ref.onKeyDown,
      onAnimationEnd = _ref.onAnimationEnd,
      onClose = _ref.onClose,
      restProps = _objectWithoutPropertiesLoose(_ref, ["ariaLabel", "className", "styles", "arrowClassName", "arrowStyles", "anchorPoint", "anchorRef", "containerRef", "arrow", "align", "direction", "position", "overflow", "isOpen", "isMounted", "isDisabled", "menuItemFocus", "offsetX", "offsetY", "children", "onKeyDown", "onAnimationEnd", "onClose"]);

  var _useState = React.useState({
    x: 0,
    y: 0
  }),
      menuPosition = _useState[0],
      setMenuPosition = _useState[1];

  var _useState2 = React.useState({}),
      arrowPosition = _useState2[0],
      setArrowPosition = _useState2[1];

  var _useState3 = React.useState(-1),
      maxHeight = _useState3[0],
      setMaxHeight = _useState3[1];

  var _useState4 = React.useState(false),
      isClosing = _useState4[0],
      setClosing = _useState4[1];

  var _useState5 = React.useState(direction),
      expandedDirection = _useState5[0],
      setExpandedDirection = _useState5[1];

  var _useContext = React.useContext(SettingsContext),
      animation = _useContext.animation,
      viewScroll = _useContext.viewScroll;

  var menuRef = React.useRef(null);
  var arrowRef = React.useRef(null);
  var menuItemsCount = React.useRef(0);
  var prevOpen = React.useRef(isOpen);

  var _useReducer = React.useReducer(hoverIndexReducer, initialHoverIndex),
      hoverIndex = _useReducer[0],
      hoverIndexDispatch = _useReducer[1];

  function hoverIndexReducer(state, _ref2) {
    var type = _ref2.type,
        index = _ref2.index;

    switch (type) {
      case HoverIndexActionTypes.RESET:
        return initialHoverIndex;

      case HoverIndexActionTypes.SET:
        return index;

      case HoverIndexActionTypes.UNSET:
        return state === index ? initialHoverIndex : state;

      case HoverIndexActionTypes.DECREASE:
        {
          var i = state;
          i--;
          if (i < 0) i = menuItemsCount.current - 1;
          return i;
        }

      case HoverIndexActionTypes.INCREASE:
        {
          var _i = state;
          _i++;
          if (_i >= menuItemsCount.current) _i = 0;
          return _i;
        }

      case HoverIndexActionTypes.FIRST:
        return menuItemsCount.current > 0 ? 0 : initialHoverIndex;

      case HoverIndexActionTypes.LAST:
        return menuItemsCount.current > 0 ? menuItemsCount.current - 1 : initialHoverIndex;

      default:
        throw new Error('hoverIndexReducer: unknown action type');
    }
  }

  var menuItems = React.useMemo(function () {
    if (!isMounted) return null;
    var index = 0;
    var permittedChildren = ['MenuDivider', 'MenuHeader', 'MenuItem', 'FocusableItem', 'MenuRadioGroup', 'SubMenu'];

    var validateChildren = function validateChildren(parent, child, permitted) {
      if (!permitted.includes(child.type && child.type.__name__)) {
        console.warn((child.type || child) + " is ignored.\n", "The permitted children inside a " + parent + " are " + permitted.join(', ') + ".");
        return false;
      }

      return true;
    };

    var items = React__default.Children.map(children, function (child) {
      if (!validateChildren('Menu or SubMenu', child, permittedChildren)) return null;

      if (child.type.__name__ === 'MenuDivider' || child.type.__name__ === 'MenuHeader') {
        return child;
      } else if (child.type.__name__ === 'MenuRadioGroup') {
        var _permittedChildren = ['MenuItem'];
        var props = {
          type: 'radio'
        };
        var radioItems = React__default.Children.map(child.props.children, function (radioChild) {
          if (!validateChildren('MenuRadioGroup', radioChild, _permittedChildren)) return null;
          return radioChild.props.disabled ? /*#__PURE__*/React__default.cloneElement(radioChild, props) : /*#__PURE__*/React__default.cloneElement(radioChild, _extends({}, props, {
            index: index++
          }));
        });
        return /*#__PURE__*/React__default.cloneElement(child, {
          children: radioItems
        });
      } else {
        return child.props.disabled ? child : /*#__PURE__*/React__default.cloneElement(child, {
          index: index++
        });
      }
    });
    menuItemsCount.current = index;
    return items;
  }, [isMounted, children]);

  var handleKeyDown = function handleKeyDown(e) {
    var handled = false;

    switch (e.key) {
      case Keys.HOME:
        hoverIndexDispatch({
          type: HoverIndexActionTypes.FIRST
        });
        handled = true;
        break;

      case Keys.END:
        hoverIndexDispatch({
          type: HoverIndexActionTypes.LAST
        });
        handled = true;
        break;

      case Keys.UP:
        hoverIndexDispatch({
          type: HoverIndexActionTypes.DECREASE
        });
        handled = true;
        break;

      case Keys.DOWN:
        hoverIndexDispatch({
          type: HoverIndexActionTypes.INCREASE
        });
        handled = true;
        break;

      case Keys.SPACE:
        if (e.target && e.target.className.includes(menuClass)) {
          e.preventDefault();
        }

        break;
    }

    if (handled) {
      e.preventDefault();
      e.stopPropagation();
    }

    safeCall(onKeyDown, e);
  };

  var handleAnimationEnd = function handleAnimationEnd(e) {
    if (isClosing) {
      setClosing(false);
      setMaxHeight(-1);
    }

    safeCall(onAnimationEnd, e);
  };

  var positionHelpers = React.useCallback(function () {
    var menuRect = menuRef.current.getBoundingClientRect();
    var containerRect = containerRef.current.getBoundingClientRect();
    var viewportWidth = document.documentElement.clientWidth;
    var viewportHeight = document.documentElement.clientHeight;

    var getLeftOverflow = function getLeftOverflow(x) {
      return containerRect.left + x;
    };

    var getRightOverflow = function getRightOverflow(x) {
      return containerRect.left + x + menuRect.width - viewportWidth;
    };

    var getTopOverflow = function getTopOverflow(y) {
      return containerRect.top + y;
    };

    var getBottomOverflow = function getBottomOverflow(y) {
      return containerRect.top + y + menuRect.height - viewportHeight;
    };

    var confineHorizontally = function confineHorizontally(x) {
      var leftOverflow = getLeftOverflow(x);

      if (leftOverflow < 0) {
        x -= leftOverflow;
      } else {
        var rightOverflow = getRightOverflow(x);

        if (rightOverflow > 0) {
          x -= rightOverflow;
          leftOverflow = getLeftOverflow(x);
          if (leftOverflow < 0) x -= leftOverflow;
        }
      }

      return x;
    };

    var confineVertically = function confineVertically(y) {
      var topOverflow = getTopOverflow(y);

      if (topOverflow < 0) {
        y -= topOverflow;
      } else {
        var bottomOverflow = getBottomOverflow(y);

        if (bottomOverflow > 0) {
          y -= bottomOverflow;
          topOverflow = getTopOverflow(y);
          if (topOverflow < 0) y -= topOverflow;
        }
      }

      return y;
    };

    return {
      menuRect: menuRect,
      containerRect: containerRect,
      viewportWidth: viewportWidth,
      viewportHeight: viewportHeight,
      getLeftOverflow: getLeftOverflow,
      getRightOverflow: getRightOverflow,
      getTopOverflow: getTopOverflow,
      getBottomOverflow: getBottomOverflow,
      confineHorizontally: confineHorizontally,
      confineVertically: confineVertically
    };
  }, [containerRef]);
  var placeArrowX = React.useCallback(function (menuX, anchorRect, containerRect, menuRect) {
    if (!arrow) return;
    var x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;
    var offset = arrowRef.current.offsetWidth * 1.25;
    x = Math.max(offset, x);
    x = Math.min(x, menuRect.width - offset);
    setArrowPosition({
      x: x
    });
  }, [arrow]);
  var placeArrowY = React.useCallback(function (menuY, anchorRect, containerRect, menuRect) {
    if (!arrow) return;
    var y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;
    var offset = arrowRef.current.offsetHeight * 1.25;
    y = Math.max(offset, y);
    y = Math.min(y, menuRect.height - offset);
    setArrowPosition({
      y: y
    });
  }, [arrow]);
  var placeLeftorRight = React.useCallback(function (_ref3, _ref4, _ref5) {
    var anchorRect = _ref3.anchorRect,
        containerRect = _ref3.containerRect,
        menuRect = _ref3.menuRect;
    var placeLeftorRightY = _ref4.placeLeftorRightY,
        placeLeftX = _ref4.placeLeftX,
        placeRightX = _ref4.placeRightX;
    var getLeftOverflow = _ref5.getLeftOverflow,
        getRightOverflow = _ref5.getRightOverflow,
        confineHorizontally = _ref5.confineHorizontally,
        confineVertically = _ref5.confineVertically;
    var computedDirection = direction;
    var y = placeLeftorRightY;

    if (position !== 'initial') {
      y = confineVertically(y);

      if (position === 'anchor') {
        y = Math.min(y, anchorRect.bottom - containerRect.top);
        y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);
      }
    }

    var x, leftOverflow, rightOverflow;

    if (computedDirection === 'left') {
      x = placeLeftX;

      if (position !== 'initial') {
        leftOverflow = getLeftOverflow(x);

        if (leftOverflow < 0) {
          rightOverflow = getRightOverflow(placeRightX);

          if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {
            x = placeRightX;
            computedDirection = 'right';
          }
        }
      }
    } else {
      x = placeRightX;

      if (position !== 'initial') {
        rightOverflow = getRightOverflow(x);

        if (rightOverflow > 0) {
          leftOverflow = getLeftOverflow(placeLeftX);

          if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {
            x = placeLeftX;
            computedDirection = 'left';
          }
        }
      }
    }

    if (position === 'auto') x = confineHorizontally(x);
    placeArrowY(y, anchorRect, containerRect, menuRect);
    return {
      x: x,
      y: y,
      computedDirection: computedDirection
    };
  }, [placeArrowY, direction, position]);
  var placeToporBottom = React.useCallback(function (_ref6, _ref7, _ref8) {
    var anchorRect = _ref6.anchorRect,
        containerRect = _ref6.containerRect,
        menuRect = _ref6.menuRect;
    var placeToporBottomX = _ref7.placeToporBottomX,
        placeTopY = _ref7.placeTopY,
        placeBottomY = _ref7.placeBottomY;
    var getTopOverflow = _ref8.getTopOverflow,
        getBottomOverflow = _ref8.getBottomOverflow,
        confineHorizontally = _ref8.confineHorizontally,
        confineVertically = _ref8.confineVertically;
    var computedDirection = direction === 'top' ? 'top' : 'bottom';
    var x = placeToporBottomX;

    if (position !== 'initial') {
      x = confineHorizontally(x);

      if (position === 'anchor') {
        x = Math.min(x, anchorRect.right - containerRect.left);
        x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);
      }
    }

    var y, topOverflow, bottomOverflow;

    if (computedDirection === 'top') {
      y = placeTopY;

      if (position !== 'initial') {
        topOverflow = getTopOverflow(y);

        if (topOverflow < 0) {
          bottomOverflow = getBottomOverflow(placeBottomY);

          if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {
            y = placeBottomY;
            computedDirection = 'bottom';
          }
        }
      }
    } else {
      y = placeBottomY;

      if (position !== 'initial') {
        bottomOverflow = getBottomOverflow(y);

        if (bottomOverflow > 0) {
          topOverflow = getTopOverflow(placeTopY);

          if (topOverflow >= 0 || -topOverflow < bottomOverflow) {
            y = placeTopY;
            computedDirection = 'top';
          }
        }
      }
    }

    if (position === 'auto') y = confineVertically(y);
    placeArrowX(x, anchorRect, containerRect, menuRect);
    return {
      x: x,
      y: y,
      computedDirection: computedDirection
    };
  }, [placeArrowX, direction, position]);
  var positionMenu = React.useCallback(function (positionHelpers, anchorRef) {
    var menuRect = positionHelpers.menuRect,
        containerRect = positionHelpers.containerRect,
        helpers = _objectWithoutPropertiesLoose(positionHelpers, ["menuRect", "containerRect"]);

    var horizontalOffset = offsetX;
    var verticalOffset = offsetY;

    if (arrow) {
      if (direction === 'left' || direction === 'right') {
        horizontalOffset += arrowRef.current.offsetWidth;
      } else {
        verticalOffset += arrowRef.current.offsetHeight;
      }
    }

    var anchorRect = anchorRef.current.getBoundingClientRect();
    var placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;
    var placeRightX = anchorRect.right - containerRect.left + horizontalOffset;
    var placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;
    var placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;
    var placeToporBottomX, placeLeftorRightY;

    if (align === 'end') {
      placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;
      placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;
    } else if (align === 'center') {
      placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;
      placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;
    } else {
      placeToporBottomX = anchorRect.left - containerRect.left;
      placeLeftorRightY = anchorRect.top - containerRect.top;
    }

    placeToporBottomX += horizontalOffset;
    placeLeftorRightY += verticalOffset;
    var rects = {
      anchorRect: anchorRect,
      containerRect: containerRect,
      menuRect: menuRect
    };
    var placements = {
      placeLeftX: placeLeftX,
      placeRightX: placeRightX,
      placeLeftorRightY: placeLeftorRightY,
      placeTopY: placeTopY,
      placeBottomY: placeBottomY,
      placeToporBottomX: placeToporBottomX
    };

    switch (direction) {
      case 'left':
      case 'right':
        return placeLeftorRight(rects, placements, helpers);

      case 'top':
      case 'bottom':
      default:
        return placeToporBottom(rects, placements, helpers);
    }
  }, [arrow, align, direction, offsetX, offsetY, placeLeftorRight, placeToporBottom]);
  var positionContextMenu = React.useCallback(function (positionHelpers, anchorPoint) {
    var menuRect = positionHelpers.menuRect,
        containerRect = positionHelpers.containerRect,
        getLeftOverflow = positionHelpers.getLeftOverflow,
        getRightOverflow = positionHelpers.getRightOverflow,
        getTopOverflow = positionHelpers.getTopOverflow,
        getBottomOverflow = positionHelpers.getBottomOverflow,
        confineHorizontally = positionHelpers.confineHorizontally,
        confineVertically = positionHelpers.confineVertically;
    var x, y;
    x = anchorPoint.x - containerRect.left;
    y = anchorPoint.y - containerRect.top;
    var rightOverflow = getRightOverflow(x);

    if (rightOverflow > 0) {
      var adjustedX = x - menuRect.width;
      var leftOverflow = getLeftOverflow(adjustedX);

      if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {
        x = adjustedX;
      }

      x = confineHorizontally(x);
    }

    var computedDirection = 'bottom';
    var bottomOverflow = getBottomOverflow(y);

    if (bottomOverflow > 0) {
      var adjustedY = y - menuRect.height;
      var topOverflow = getTopOverflow(adjustedY);

      if (topOverflow >= 0 || -topOverflow < bottomOverflow) {
        y = adjustedY;
        computedDirection = 'top';
      }

      y = confineVertically(y);
    }

    return {
      x: x,
      y: y,
      computedDirection: computedDirection
    };
  }, []);
  var handlePosition = React.useCallback(function () {
    var helpers = positionHelpers();
    var results = {
      computedDirection: 'bottom'
    };

    if (anchorPoint) {
      results = positionContextMenu(helpers, anchorPoint);
    } else if (anchorRef) {
      results = positionMenu(helpers, anchorRef);
    }

    var _results = results,
        x = _results.x,
        y = _results.y,
        computedDirection = _results.computedDirection;

    if (overflow !== 'visible') {
      var menuRect = helpers.menuRect,
          getTopOverflow = helpers.getTopOverflow,
          getBottomOverflow = helpers.getBottomOverflow;
      setMaxHeight(function (height) {
        var newHeight = -1;
        var bottomOverflow = getBottomOverflow(y);

        if (bottomOverflow > 0 || bottomOverflow === 0 && height >= 0) {
          newHeight = menuRect.height - bottomOverflow;
        } else {
          var topOverflow = getTopOverflow(y);

          if (topOverflow < 0 || topOverflow === 0 && height >= 0) {
            newHeight = menuRect.height + topOverflow;
            if (newHeight >= 0) y -= topOverflow;
          }
        }

        return newHeight;
      });
    }

    setMenuPosition({
      x: x,
      y: y
    });
    setExpandedDirection(computedDirection);
  }, [anchorPoint, anchorRef, overflow, positionHelpers, positionMenu, positionContextMenu]);
  React.useLayoutEffect(function () {
    if (isOpen) handlePosition();
  }, [isOpen, handlePosition]);
  React.useEffect(function () {
    if (!isOpen || viewScroll === 'initial') return;
    var scroll = viewScroll;
    if (scroll === 'auto' && overflow !== 'visible') scroll = 'close';

    var handleScroll = function handleScroll() {
      if (scroll === 'auto') {
        handlePosition();
      } else {
        safeCall(onClose, {
          reason: CloseReason.SCROLL
        });
      }
    };

    window.addEventListener('scroll', handleScroll);
    return function () {
      return window.removeEventListener('scroll', handleScroll);
    };
  }, [isOpen, overflow, onClose, viewScroll, handlePosition]);
  React.useLayoutEffect(function () {
    if (animation && isMounted) {
      if (isOpen) {
        setClosing(false);
      } else if (isOpen !== prevOpen.current) {
        setClosing(true);
      }
    }

    prevOpen.current = isOpen;
  }, [animation, isMounted, isOpen]);
  React.useEffect(function () {
    if (!isOpen) {
      hoverIndexDispatch({
        type: HoverIndexActionTypes.RESET
      });
      if (!animation) setMaxHeight(-1);
    }

    var id = setTimeout(function () {
      if (!isOpen || menuRef.current.contains(document.activeElement)) return;
      menuRef.current.focus();

      if (menuItemFocus.position === FocusPositions.FIRST) {
        hoverIndexDispatch({
          type: HoverIndexActionTypes.FIRST
        });
      } else if (menuItemFocus.position === FocusPositions.LAST) {
        hoverIndexDispatch({
          type: HoverIndexActionTypes.LAST
        });
      }
    }, 150);
    return function () {
      return clearTimeout(id);
    };
  }, [animation, isOpen, menuItemFocus]);
  var context = React.useMemo(function () {
    return {
      isParentOpen: isOpen,
      hoverIndex: hoverIndex,
      hoverIndexDispatch: hoverIndexDispatch
    };
  }, [isOpen, hoverIndex]);
  var modifiers = {
    open: isOpen,
    closing: isClosing,
    animation: animation,
    dir: animation && expandedDirection
  };
  var userModifiers = Object.freeze(_extends({}, modifiers, {
    dir: expandedDirection
  }));
  var arrowModifiers = Object.freeze({
    dir: expandedDirection
  });
  var overflowStyles = null;

  if (maxHeight >= 0) {
    overflowStyles = {
      maxHeight: maxHeight,
      overflow: overflow
    };
  }

  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isMounted && /*#__PURE__*/React__default.createElement("ul", _extends({}, restProps, {
    className: bem(menuClass, null, modifiers)(className, userModifiers),
    role: "menu",
    tabIndex: "-1",
    "aria-disabled": isDisabled,
    "aria-label": ariaLabel,
    ref: menuRef,
    onKeyDown: handleKeyDown,
    onAnimationEnd: handleAnimationEnd,
    style: _extends({}, flatStyles(styles, userModifiers), overflowStyles, {
      left: menuPosition.x + "px",
      top: menuPosition.y + "px"
    })
  }), arrow && /*#__PURE__*/React__default.createElement("div", {
    className: bem(menuClass, menuArrowClass, arrowModifiers)(arrowClassName),
    style: _extends({}, flatStyles(arrowStyles, arrowModifiers), {
      left: arrowPosition.x && arrowPosition.x + "px",
      top: arrowPosition.y && arrowPosition.y + "px"
    }),
    ref: arrowRef,
    role: "presentation"
  }), /*#__PURE__*/React__default.createElement(MenuListContext.Provider, {
    value: context
  }, menuItems)));
}), 'MenuList');

var useMenuList = function useMenuList(menuListProps, id, animation, debugging, viewScroll, children, onClick, onClose, skipClick) {
  var containerRef = React.useRef(null);
  var settings = React.useMemo(function () {
    return {
      animation: animation,
      debugging: debugging,
      viewScroll: viewScroll
    };
  }, [animation, debugging, viewScroll]);
  var eventHandlers = React.useMemo(function () {
    return {
      handleClick: function handleClick(event, isStopPropagation, isCheckorRadio) {
        if (!isCheckorRadio || event.key !== Keys.SPACE) {
          safeCall(onClose, {
            key: event.key,
            reason: CloseReason.CLICK
          });
        }

        if (!isStopPropagation) safeCall(onClick, event);
      },
      handleClose: function handleClose(key) {
        safeCall(onClose, {
          key: key,
          reason: CloseReason.CLICK
        });
      }
    };
  }, [onClick, onClose]);

  var handleKeyDown = function handleKeyDown(_ref) {
    var key = _ref.key;

    switch (key) {
      case Keys.ESC:
        safeCall(onClose, {
          key: key,
          reason: CloseReason.CANCEL
        });
        break;
    }
  };

  var handleBlur = function handleBlur(e) {
    if (menuListProps.isOpen && !e.currentTarget.contains(e.relatedTarget) && !debugging) {
      safeCall(onClose, {
        reason: CloseReason.BLUR
      });

      if (skipClick) {
        skipClick.current = true;
        setTimeout(function () {
          return skipClick.current = false;
        }, 300);
      }
    }
  };

  return /*#__PURE__*/React__default.createElement("div", {
    id: id,
    className: bem(menuContainerClass)(),
    role: "presentation",
    ref: containerRef,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur
  }, /*#__PURE__*/React__default.createElement(SettingsContext.Provider, {
    value: settings
  }, /*#__PURE__*/React__default.createElement(EventHandlersContext.Provider, {
    value: eventHandlers
  }, /*#__PURE__*/React__default.createElement(MenuList, _extends({}, menuListProps, {
    containerRef: containerRef,
    onClose: onClose
  }), children))));
};

var Menu = /*#__PURE__*/React__default.memo(function Menu(_ref) {
  var ariaLabel = _ref['aria-label'],
      id = _ref.id,
      className = _ref.className,
      styles = _ref.styles,
      arrowClassName = _ref.arrowClassName,
      arrowStyles = _ref.arrowStyles,
      animation = _ref.animation,
      debugging = _ref.debugging,
      viewScroll = _ref.viewScroll,
      keepMounted = _ref.keepMounted,
      arrow = _ref.arrow,
      align = _ref.align,
      direction = _ref.direction,
      position = _ref.position,
      overflow = _ref.overflow,
      menuButton = _ref.menuButton,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      children = _ref.children,
      onClick = _ref.onClick,
      onChange = _ref.onChange;

  var _useMenuState = useMenuState(keepMounted),
      isMounted = _useMenuState.isMounted,
      isOpen = _useMenuState.isOpen,
      menuItemFocus = _useMenuState.menuItemFocus,
      openMenu = _useMenuState.openMenu,
      closeMenu = _useMenuState.closeMenu;

  useMenuChange(onChange, isOpen);
  var skipClick = React.useRef(false);
  var buttonRef = React.useRef(null);
  var button = safeCall(menuButton, {
    open: isOpen
  });
  if (!button) throw new Error('Menu requires a menuButton prop.');
  var handleClose = React.useCallback(function (e) {
    closeMenu();
    if (e.key) buttonRef.current.focus();
  }, [closeMenu]);
  var handleClick = React.useCallback(function (e) {
    if (skipClick.current) return;
    openMenu(e.detail === 0 ? FocusPositions.FIRST : FocusPositions.INITIAL);
  }, [openMenu]);
  var handleKeyDown = React.useCallback(function (e) {
    var handled = false;

    switch (e.key) {
      case Keys.UP:
        openMenu(FocusPositions.LAST);
        handled = true;
        break;

      case Keys.DOWN:
        openMenu(FocusPositions.FIRST);
        handled = true;
        break;
    }

    if (handled) e.preventDefault();
  }, [openMenu]);
  var renderButton = React.useMemo(function () {
    if (!button) return null;
    var buttonProps = {
      ref: buttonRef,
      onClick: handleClick,
      onKeyDown: handleKeyDown
    };

    if (button.type.__name__ === 'MenuButton') {
      buttonProps.isOpen = isOpen;
    }

    return /*#__PURE__*/React__default.cloneElement(button, buttonProps);
  }, [button, isOpen, handleClick, handleKeyDown]);
  var menuList = useMenuList({
    ariaLabel: ariaLabel || (typeof button.props.children === 'string' ? button.props.children : 'Menu'),
    className: className,
    styles: styles,
    arrowClassName: arrowClassName,
    arrowStyles: arrowStyles,
    anchorRef: buttonRef,
    arrow: arrow,
    align: align,
    direction: direction,
    position: position,
    overflow: overflow,
    isOpen: isOpen,
    isMounted: isMounted,
    menuItemFocus: menuItemFocus,
    offsetX: offsetX,
    offsetY: offsetY
  }, id, animation, debugging, viewScroll, children, onClick, handleClose, skipClick);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, renderButton, menuList);
});
Menu.propTypes = _extends({}, menuPropTypesBase, {
  keepMounted: PropTypes.bool,
  menuButton: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,
  onChange: PropTypes.func
});
Menu.defaultProps = _extends({}, menuDefaultPropsBase, {
  keepMounted: true
});

var ControlledMenu = /*#__PURE__*/React__default.memo(function ControlledMenu(_ref) {
  var ariaLabel = _ref['aria-label'],
      id = _ref.id,
      className = _ref.className,
      styles = _ref.styles,
      arrowClassName = _ref.arrowClassName,
      arrowStyles = _ref.arrowStyles,
      animation = _ref.animation,
      debugging = _ref.debugging,
      viewScroll = _ref.viewScroll,
      anchorPoint = _ref.anchorPoint,
      anchorRef = _ref.anchorRef,
      arrow = _ref.arrow,
      align = _ref.align,
      direction = _ref.direction,
      position = _ref.position,
      overflow = _ref.overflow,
      isOpen = _ref.isOpen,
      isMounted = _ref.isMounted,
      menuItemFocus = _ref.menuItemFocus,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      children = _ref.children,
      onClick = _ref.onClick,
      onClose = _ref.onClose,
      restProps = _objectWithoutPropertiesLoose(_ref, ["aria-label", "id", "className", "styles", "arrowClassName", "arrowStyles", "animation", "debugging", "viewScroll", "anchorPoint", "anchorRef", "arrow", "align", "direction", "position", "overflow", "isOpen", "isMounted", "menuItemFocus", "offsetX", "offsetY", "children", "onClick", "onClose"]);

  return useMenuList(_extends({}, restProps, {
    ariaLabel: ariaLabel || 'Menu',
    className: className,
    styles: styles,
    arrowClassName: arrowClassName,
    arrowStyles: arrowStyles,
    anchorPoint: anchorPoint,
    anchorRef: anchorRef,
    arrow: arrow,
    align: align,
    direction: direction,
    position: position,
    overflow: overflow,
    isOpen: isOpen,
    isMounted: isMounted,
    menuItemFocus: menuItemFocus,
    offsetX: offsetX,
    offsetY: offsetY
  }), id, animation, debugging, viewScroll, children, onClick, onClose);
});
ControlledMenu.propTypes = _extends({}, menuPropTypesBase, {
  anchorPoint: PropTypes.exact({
    x: PropTypes.number,
    y: PropTypes.number
  }),
  anchorRef: PropTypes.object,
  isOpen: PropTypes.bool,
  isMounted: PropTypes.bool,
  menuItemFocus: PropTypes.exact({
    position: PropTypes.string
  }),
  onClose: PropTypes.func
});
ControlledMenu.defaultProps = _extends({}, menuDefaultPropsBase, {
  isMounted: true,
  menuItemFocus: {
    position: FocusPositions.INITIAL
  }
});

var SubMenu = defineName( /*#__PURE__*/React__default.memo(function SubMenu(_ref) {
  var ariaLabel = _ref['aria-label'],
      className = _ref.className,
      styles = _ref.styles,
      arrowClassName = _ref.arrowClassName,
      arrowStyles = _ref.arrowStyles,
      itemClassName = _ref.itemClassName,
      itemStyles = _ref.itemStyles,
      arrow = _ref.arrow,
      align = _ref.align,
      direction = _ref.direction,
      position = _ref.position,
      overflow = _ref.overflow,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      disabled = _ref.disabled,
      keepMounted = _ref.keepMounted,
      label = _ref.label,
      index = _ref.index,
      children = _ref.children,
      onChange = _ref.onChange;

  var _useMenuState = useMenuState(keepMounted),
      isMounted = _useMenuState.isMounted,
      isOpen = _useMenuState.isOpen,
      menuItemFocus = _useMenuState.menuItemFocus,
      openMenu = _useMenuState.openMenu,
      closeMenu = _useMenuState.closeMenu;

  var _useContext = React.useContext(MenuListContext),
      isParentOpen = _useContext.isParentOpen,
      hoverIndex = _useContext.hoverIndex,
      hoverIndexDispatch = _useContext.hoverIndexDispatch;

  var _useContext2 = React.useContext(SettingsContext),
      debugging = _useContext2.debugging;

  var isHovering = hoverIndex === index;

  var _useActiveState = useActiveState(isHovering, Keys.RIGHT),
      isActive = _useActiveState.isActive,
      onKeyUp = _useActiveState.onKeyUp,
      onBlur = _useActiveState.onBlur,
      activeStateHandlers = _objectWithoutPropertiesLoose(_useActiveState, ["isActive", "onKeyUp", "onBlur"]);

  var containerRef = React.useRef(null);
  var itemRef = React.useRef(null);
  var timeoutId = React.useRef();
  var isDisabled = disabled ? true : undefined;
  useMenuChange(onChange, isOpen);
  var handleClose = React.useCallback(function () {
    itemRef.current.focus();
  }, []);

  var handleMouseEnter = function handleMouseEnter() {
    if (isDisabled) return;
    hoverIndexDispatch({
      type: HoverIndexActionTypes.SET,
      index: index
    });
    timeoutId.current = setTimeout(function () {
      timeoutId.current = null;
      openMenu();
    }, 300);
  };

  var handleMouseLeave = function handleMouseLeave() {
    if (isDisabled) return;
    clearTimeout(timeoutId.current);

    if (!isOpen) {
      hoverIndexDispatch({
        type: HoverIndexActionTypes.UNSET,
        index: index
      });
    }
  };

  var handleClick = function handleClick() {
    if (isDisabled) return;
    openMenu();
  };

  var handleKeyDown = function handleKeyDown(e) {
    var handled = false;

    switch (e.key) {
      case Keys.LEFT:
        if (isOpen) {
          handleClose();
          handled = true;
        }

        break;

      case Keys.RIGHT:
        if (!isOpen) handled = true;
        break;
    }

    if (handled) {
      e.preventDefault();
      e.stopPropagation();
    }
  };

  var handleKeyUp = function handleKeyUp(e) {
    if (!isActive) return;
    onKeyUp(e);

    switch (e.key) {
      case Keys.SPACE:
      case Keys.ENTER:
      case Keys.RIGHT:
        openMenu(FocusPositions.FIRST);
        break;
    }
  };

  var handleBlur = function handleBlur(e) {
    onBlur(e);
    if (debugging) return;

    if (!e.currentTarget.contains(e.relatedTarget)) {
      closeMenu();
      hoverIndexDispatch({
        type: HoverIndexActionTypes.UNSET,
        index: index
      });
    } else if (itemRef.current === e.relatedTarget) {
      closeMenu();
    }
  };

  React.useEffect(function () {
    if (isHovering && isParentOpen) {
      itemRef.current.focus();
    } else {
      closeMenu();
    }
  }, [isHovering, isParentOpen, closeMenu]);
  var modifiers = Object.freeze({
    open: isOpen,
    hover: isHovering,
    active: isActive && !isDisabled,
    disabled: isDisabled
  });
  return /*#__PURE__*/React__default.createElement("li", {
    className: bem(menuClass, subMenuClass)(),
    role: "presentation",
    ref: containerRef,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur
  }, /*#__PURE__*/React__default.createElement("div", _extends({
    className: bem(menuClass, menuItemClass, modifiers)(itemClassName),
    style: flatStyles(itemStyles, modifiers),
    role: "menuitem",
    "aria-haspopup": "true",
    "aria-expanded": isOpen,
    "aria-disabled": isDisabled,
    tabIndex: isHovering && !isOpen ? 0 : -1,
    ref: itemRef,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onKeyUp: handleKeyUp
  }, activeStateHandlers), safeCall(label, modifiers)), /*#__PURE__*/React__default.createElement(MenuList, {
    ariaLabel: ariaLabel || (typeof label === 'string' ? label : 'Submenu'),
    className: className,
    styles: styles,
    arrowClassName: arrowClassName,
    arrowStyles: arrowStyles,
    anchorRef: itemRef,
    containerRef: containerRef,
    arrow: arrow,
    align: align,
    direction: direction,
    position: position,
    overflow: overflow,
    offsetX: offsetX,
    offsetY: offsetY,
    isOpen: isOpen,
    isMounted: isMounted,
    isDisabled: isDisabled,
    menuItemFocus: menuItemFocus,
    onClose: handleClose
  }, children));
}), 'SubMenu');
SubMenu.propTypes = _extends({}, sharedMenuPropTypes, stylePropTypes('item'), {
  disabled: PropTypes.bool,
  keepMounted: PropTypes.bool,
  label: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
  onChange: PropTypes.func
});
SubMenu.defaultProps = _extends({}, sharedMenuDefaultProp, {
  direction: 'right',
  keepMounted: true
});

var MenuItem = defineName( /*#__PURE__*/React__default.memo(function MenuItem(_ref) {
  var className = _ref.className,
      styles = _ref.styles,
      value = _ref.value,
      href = _ref.href,
      type = _ref.type,
      checked = _ref.checked,
      disabled = _ref.disabled,
      index = _ref.index,
      children = _ref.children,
      onClick = _ref.onClick,
      restProps = _objectWithoutPropertiesLoose(_ref, ["className", "styles", "value", "href", "type", "checked", "disabled", "index", "children", "onClick"]);

  var _useItemState = useItemState(disabled, index),
      ref = _useItemState.ref,
      isHovering = _useItemState.isHovering,
      isDisabled = _useItemState.isDisabled,
      setHover = _useItemState.setHover,
      unsetHover = _useItemState.unsetHover;

  var eventHandlers = React.useContext(EventHandlersContext);
  var radioGroup = React.useContext(RadioGroupContext);

  var _useActiveState = useActiveState(isHovering),
      isActive = _useActiveState.isActive,
      onKeyUp = _useActiveState.onKeyUp,
      onBlur = _useActiveState.onBlur,
      activeStateHandlers = _objectWithoutPropertiesLoose(_useActiveState, ["isActive", "onKeyUp", "onBlur"]);

  var isRadio = type === 'radio';
  var isCheckBox = type === 'checkbox';
  var isAnchor = href && !isDisabled && !isRadio && !isCheckBox;

  var handleClick = function handleClick(key) {
    if (isDisabled) return;
    var isStopPropagation = false;
    var event = {
      value: value,
      key: key
    };

    if (isCheckBox) {
      event.checked = !checked;
    }

    if (isRadio) {
      event.name = radioGroup.name;
      isStopPropagation = true;
      safeCall(radioGroup.onChange, event);
    } else {
      isStopPropagation = safeCall(onClick, event) === false;
    }

    eventHandlers.handleClick(event, isStopPropagation, isCheckBox || isRadio);
  };

  var handleKeyUp = function handleKeyUp(e) {
    if (!isActive) return;
    onKeyUp(e);

    switch (e.key) {
      case Keys.SPACE:
      case Keys.ENTER:
        if (isAnchor) {
          ref.current.click();
        } else {
          handleClick(e.key);
        }

        break;
    }
  };

  var handleBlur = function handleBlur(e) {
    onBlur(e);
    unsetHover(e);
  };

  var modifiers = Object.freeze({
    type: type,
    disabled: isDisabled,
    hover: isHovering,
    active: isActive && !isDisabled,
    checked: isRadio ? radioGroup.value === value : isCheckBox ? !!checked : undefined,
    anchor: isAnchor
  });

  var menuItemProps = _extends({
    className: bem(menuClass, menuItemClass, modifiers)(className),
    style: flatStyles(styles, modifiers),
    role: isRadio ? 'menuitemradio' : isCheckBox ? 'menuitemcheckbox' : 'menuitem',
    'aria-checked': modifiers.checked,
    'aria-disabled': isDisabled,
    tabIndex: isHovering ? 0 : -1,
    ref: ref,
    onMouseEnter: setHover,
    onMouseLeave: unsetHover,
    onKeyUp: handleKeyUp,
    onBlur: handleBlur,
    onClick: function onClick() {
      return handleClick();
    }
  }, activeStateHandlers);

  var renderChildren = safeCall(children, modifiers);

  if (isAnchor) {
    return /*#__PURE__*/React__default.createElement("li", {
      role: "presentation"
    }, /*#__PURE__*/React__default.createElement("a", _extends({}, restProps, {
      href: href
    }, menuItemProps), renderChildren));
  } else {
    return /*#__PURE__*/React__default.createElement("li", menuItemProps, renderChildren);
  }
}), 'MenuItem');
MenuItem.propTypes = _extends({}, stylePropTypes(), {
  value: PropTypes.any,
  href: PropTypes.string,
  type: PropTypes.oneOf(['checkbox', 'radio']),
  checked: PropTypes.bool,
  disabled: PropTypes.bool,
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
  onClick: PropTypes.func
});

var FocusableItem = defineName( /*#__PURE__*/React__default.memo(function FocusableItem(_ref) {
  var className = _ref.className,
      styles = _ref.styles,
      disabled = _ref.disabled,
      index = _ref.index,
      children = _ref.children;

  var _useItemState = useItemState(disabled, index),
      ref = _useItemState.ref,
      isHovering = _useItemState.isHovering,
      isDisabled = _useItemState.isDisabled,
      setHover = _useItemState.setHover,
      unsetHover = _useItemState.unsetHover;

  var _useContext = React.useContext(EventHandlersContext),
      handleClose = _useContext.handleClose;

  var baseParams = {
    disabled: isDisabled,
    hover: isHovering
  };
  var modifiers = Object.freeze(_extends({}, baseParams, {
    focusable: true
  }));
  var renderChildren = safeCall(children, _extends({}, baseParams, {
    ref: ref,
    closeMenu: handleClose
  }));

  var handleBlur = function handleBlur(e) {
    if (!e.currentTarget.contains(e.relatedTarget)) {
      unsetHover(e);
    }
  };

  return /*#__PURE__*/React__default.createElement("li", {
    className: bem(menuClass, menuItemClass, modifiers)(className),
    style: flatStyles(styles, modifiers),
    "aria-disabled": isDisabled,
    role: "menuitem",
    tabIndex: "-1",
    onMouseEnter: setHover,
    onFocus: setHover,
    onBlur: handleBlur
  }, renderChildren);
}), 'FocusableItem');
FocusableItem.propTypes = _extends({}, stylePropTypes(), {
  disabled: PropTypes.bool,
  children: PropTypes.func.isRequired
});

var MenuDivider = defineName( /*#__PURE__*/React__default.memo(function MenuDivider(_ref) {
  var className = _ref.className,
      styles = _ref.styles;
  return /*#__PURE__*/React__default.createElement("li", {
    className: bem(menuClass, menuDividerClass)(className),
    style: flatStyles(styles),
    role: "separator"
  });
}), 'MenuDivider');
MenuDivider.propTypes = _extends({}, stylePropTypes());

var MenuHeader = defineName( /*#__PURE__*/React__default.memo(function MenuHeader(_ref) {
  var className = _ref.className,
      styles = _ref.styles,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement("li", {
    className: bem(menuClass, menuHeaderClass)(className),
    style: flatStyles(styles),
    role: "presentation"
  }, children);
}), 'MenuHeader');
MenuHeader.propTypes = _extends({}, stylePropTypes());

var MenuRadioGroup = defineName( /*#__PURE__*/React__default.memo(function MenuRadioGroup(_ref) {
  var ariaLabel = _ref['aria-label'],
      className = _ref.className,
      styles = _ref.styles,
      name = _ref.name,
      value = _ref.value,
      children = _ref.children,
      onChange = _ref.onChange;
  var contextValue = React.useMemo(function () {
    return {
      name: name,
      value: value,
      onChange: onChange
    };
  }, [name, value, onChange]);
  return /*#__PURE__*/React__default.createElement("li", {
    role: "presentation"
  }, /*#__PURE__*/React__default.createElement("ul", {
    className: bem(menuClass, radioGroupClass)(className),
    style: flatStyles(styles),
    role: "group",
    "aria-label": ariaLabel || name || 'Radio group'
  }, /*#__PURE__*/React__default.createElement(RadioGroupContext.Provider, {
    value: contextValue
  }, children)));
}), 'MenuRadioGroup');
MenuRadioGroup.propTypes = _extends({}, stylePropTypes(), {
  'aria-label': PropTypes.string,
  name: PropTypes.string,
  value: PropTypes.any,
  children: PropTypes.node.isRequired,
  onChange: PropTypes.func
});

exports.ControlledMenu = ControlledMenu;
exports.FocusableItem = FocusableItem;
exports.Menu = Menu;
exports.MenuButton = MenuButton;
exports.MenuDivider = MenuDivider;
exports.MenuHeader = MenuHeader;
exports.MenuItem = MenuItem;
exports.MenuRadioGroup = MenuRadioGroup;
exports.SubMenu = SubMenu;
exports.useMenuState = useMenuState;
